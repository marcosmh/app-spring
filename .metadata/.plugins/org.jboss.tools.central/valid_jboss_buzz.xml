<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><title>JBoss Tools Aggregated Feed</title><link rel="alternate" href="http://tools.jboss.org" /><subtitle>JBoss Tools Aggregated Feed</subtitle><dc:creator>JBoss Tools</dc:creator><entry><title>How to use Ansible to create a VM on Azure</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/06/15/how-use-ansible-create-vm-azure" /><author><name>Deepankar Jain</name></author><id>32865531-f2b4-4927-ab77-8d80f69d9656</id><updated>2023-06-15T18:00:00Z</updated><published>2023-06-15T18:00:00Z</published><summary type="html">&lt;p&gt;In our &lt;a href="https://developers.redhat.com/articles/2023/06/15/how-automate-vm-creation-azure-ansible-cli#"&gt;previous article&lt;/a&gt;, we explored how to use the Red Hat Ansible Automation Platform's CLI to create a virtual machine (VM) in Microsoft Azure. This time, we'll take things a step further and leverage the power of the Ansible Automation Platform to automate the process. The Ansible Automation Platform is a powerful tool that enables you to manage your infrastructure more efficiently, with less manual intervention.&lt;/p&gt; &lt;p&gt;Follow the series:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Part 1: &lt;a href="https://developers.redhat.com/articles/2023/06/15/how-automate-vm-creation-azure-ansible-cli#"&gt;How to automate VM creation on Azure with Ansible CLI&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Part 2: How to use Ansible to create a VM on Azure&lt;/strong&gt;&lt;/li&gt; &lt;li&gt;Part 3: &lt;a href="https://developers.redhat.com/articles/2023/06/15/how-use-ansible-create-vm-azure-workflow"&gt;How to use Ansible to create a VM on Azure via workflow&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;By using the &lt;a href="https://developers.redhat.com/products/ansible/overview"&gt;Ansible Automation Platform&lt;/a&gt;, we can create a streamlined process for deploying VMs in Azure, reducing errors and saving time. In this article, we'll dive into the details of how to use the Ansible Automation Platform to create VMs in Azure.&lt;/p&gt; &lt;h2&gt;Prerequisites&lt;/h2&gt; &lt;p&gt;1. The operating system on your local machine must be Red Hat Enterprise Linux (&lt;a href="https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux"&gt;RHEL&lt;/a&gt;).&lt;/p&gt; &lt;p&gt;2. Before you can complete any of the following tasks, you must create a &lt;a href="https://access.redhat.com/terms-based-registry/"&gt;registry service account&lt;/a&gt;. To log in to service account (SA), you'll need to use a container runtime such as Podman or Docker. &lt;a href="https://podman.io/"&gt;Podman&lt;/a&gt; is a powerful and secure open-source tool that can be used as an alternative to Docker, with the added benefits of not requiring a daemon to run containers and having a more lightweight footprint. We recommend &lt;a href="https://podman.io/getting-started/installation"&gt;installing Podman&lt;/a&gt;. This &lt;a href="https://developers.redhat.com/articles/podman-next-generation-linux-container-tools"&gt;article&lt;/a&gt; explains how Podman offers a more efficient container experience.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;podman login registry.redhat.io Username: {REGISTRY-SERVICE-ACCOUNT-USERNAME} Password: {REGISTRY-SERVICE-ACCOUNT-PASSWORD} Login Succeeded!&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Once we are successful in logging into the SA, we need to create a container image by using a Dockerfile containing the following context:&lt;/p&gt; &lt;pre&gt; &lt;code&gt;FROM registry.redhat.io/ansible-automation-platform-22/ee-supported-rhel8:latest RUN pip3 install 'ansible[azure]' RUN ansible-galaxy collection install azure.azcollection RUN pip3 install -r ~/.ansible/collections/ansible_collections/azure/azcollection/requirements-azure.txt&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Build an image using Podman as follows:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;podman build -t &lt;image-name&gt;.&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Push the image into the container image registry. Log in to the private container image registry using the &lt;code&gt;podman login&lt;/code&gt; command before pushing.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;podman push &lt;image-name&gt;&lt;/code&gt;&lt;/pre&gt; &lt;div&gt;Add the image name in the execution environment, as shown in Figure 1. You can also use the &lt;a href="https://developers.redhat.com/learning/learn%3Aansible/resource/resources%3Aget-started-ansible-automation-platform-builder"&gt;execution environment builder&lt;/a&gt; to create a custom execution environment. &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/screenshot_from_2023-04-27_11-58-11.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/screenshot_from_2023-04-27_11-58-11.png?itok=xXki-AuG" width="600" height="295" alt="A screenshot of the execution environment page of Ansible Automation Platform." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 1: The execution environment page of Ansible Automation Platform.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;3. Create an &lt;a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal"&gt;Azure Active Directory&lt;/a&gt; (Azure AD) account, a service principal, and give permissions in Azure.&lt;/p&gt; &lt;p&gt;4. Follow these &lt;a href="https://learn.microsoft.com/en-us/azure/industry/training-services/microsoft-community-training/frequently-asked-questions/generate-new-clientsecret-link-to-key-vault"&gt;instructions&lt;/a&gt; to generate a client secret for the service principal. &lt;/p&gt; &lt;p&gt;5. Click &lt;strong&gt;Credentials&lt;/strong&gt; under &lt;strong&gt;Resources &lt;/strong&gt;and select &lt;strong&gt;Microsoft Azure Resource Manager.&lt;/strong&gt; Then, enter your subscription_id, tenant id, client id, secret, username, and password (Figure 2).&lt;/p&gt; &lt;/div&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/screenshot_from_2023-04-27_09-34-59.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/screenshot_from_2023-04-27_09-34-59.png?itok=aXDBdtnd" width="600" height="317" alt="A screenshot of the Azure credentials page in Ansible." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 2: Enter your Azure credentials in Ansible Automation Platform.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;Creating and configuring the project&lt;/h2&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;Install the Ansible Automation Platform by following these &lt;a href="https://developers.redhat.com/articles/2023/01/01/how-install-red-hat-ansible-automation-platform-rhel-9"&gt;instructions&lt;/a&gt;.&lt;/li&gt; &lt;li aria-level="1"&gt;Log in to the Ansible Automation Platform Portal in browser.&lt;/li&gt; &lt;li aria-level="1"&gt;Navigate to the &lt;strong&gt;Projects&lt;/strong&gt; tab under &lt;strong&gt;Resources&lt;/strong&gt; in the left pane.&lt;/li&gt; &lt;li aria-level="1"&gt;Click &lt;strong&gt;Add&lt;/strong&gt; to create a new project.&lt;/li&gt; &lt;li aria-level="1"&gt;Enter a name for the project and choose &lt;strong&gt;Git&lt;/strong&gt; as the source control type with the URL: https://github.com/redhat-developer-demos/ansible-automation-platform-cloud-solutions in the &lt;strong&gt;Source Control URL&lt;/strong&gt; field. If you're interested in checking out the Ansible Playbooks, you can find them on &lt;a href="https://github.com/redhat-developer-demos/ansible-automation-platform-cloud-solutions"&gt;Github&lt;/a&gt;.&lt;/li&gt; &lt;li aria-level="1"&gt;Save the changes and wait for the operation to complete successfully (Figure 3).&lt;/li&gt; &lt;/ul&gt;&lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/screenshot_from_2023-04-27_09-37-05.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/screenshot_from_2023-04-27_09-37-05.png?itok=5w6HVdXy" width="600" height="129" alt="A screenshot of the source control project in Ansible Automation Platform." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 3: The source control in the project in Ansible Automation Platform.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;Creating and configuring the job template&lt;/h2&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;Go to the &lt;strong&gt;Templates&lt;/strong&gt; tab under resources in the left pane, click the &lt;strong&gt;add&lt;/strong&gt; button, and select &lt;strong&gt;Job template&lt;/strong&gt; from the options.&lt;/li&gt; &lt;li aria-level="1"&gt;Enter a name for the job you want to create, select the &lt;strong&gt;Demo-Inventory&lt;/strong&gt; or &lt;strong&gt;Default inventory&lt;/strong&gt; in the &lt;strong&gt;Inventory&lt;/strong&gt; section.&lt;/li&gt; &lt;li aria-level="1"&gt;In the &lt;strong&gt;Project&lt;/strong&gt; section, click on the project name you previously created and select the Azure/create_vm_job_template.yml file.&lt;/li&gt; &lt;/ul&gt;&lt;h3&gt;Configuring the variables and execution environment&lt;/h3&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;Click on the &lt;strong&gt;Variables&lt;/strong&gt; section and add the variables as follows:&lt;/li&gt; &lt;/ul&gt;&lt;pre&gt; &lt;code class="language-yaml"&gt;--- vm_name: "Test-Ansible" vm_size: "Standard_B1ls" vm_image: "RedHat:RHEL:8-LVM:latest" vm_username: "testansible" vm_password: "my-password@1234" rg_name: "test-ansible" vnet_name: "test-ansible" subnet_name: "test-ansible" location: "centralindia" offer: “CentOS” publisher: “OpenLogic” sku: “7.5” version: ”latest”&lt;/code&gt;&lt;/pre&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;Select the credentials you previously created under the selected category (Figure 4).&lt;/li&gt; &lt;/ul&gt;&lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/screenshot_from_2023-04-27_09-40-15.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/screenshot_from_2023-04-27_09-40-15.png?itok=dfwqZin1" width="600" height="259" alt="A screenshot of the form for selecting pre-configured Azure credentials." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 4 : Select pre-configured Azure credentials for secure authentication.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;Select the execution environment you previously created (Figure 5).&lt;/li&gt; &lt;/ul&gt;&lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/screenshot_from_2023-04-27_09-42-54.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/screenshot_from_2023-04-27_09-42-54.png?itok=QISI_KtX" width="600" height="408" alt="Figure 4: Selecting pre-configured execution environment" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 5: Selecting the pre-configured execution environment.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;Save your changes by clicking the &lt;strong&gt;Save&lt;/strong&gt; button.&lt;/li&gt; &lt;li&gt;Click the &lt;strong&gt;Launch&lt;/strong&gt; button to launch the job.&lt;/li&gt; &lt;li&gt;Once the job is launched using the Ansible Automation Platform, the system will generate an output, as shown in Figure 6. The output displays the job status and the progress of the VM creation process.&lt;/li&gt; &lt;/ul&gt;&lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/screenshot_2023-06-15_at_12.04.09_pm.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/screenshot_2023-06-15_at_12.04.09_pm.png?itok=LWz4-Zuq" width="600" height="281" alt="A screenshot of the output from the job in the Ansible Automation Platform console." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 6: The output from the job in the Ansible Automation Platform console.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;You can&lt;span&gt; check the virtual machine by navigating to the Azure portal&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; &lt;h2&gt;What’s next?&lt;/h2&gt; &lt;p&gt;In this article, we demonstrated how to use the Ansible Automation Platform to create a VM in Microsoft Azure. You learned how the Ansible Automation Platform can streamline the process of deploying VMs in Azure, making it more efficient and less error-prone. By using the power of automation, we can save time and free up resources to focus on other important tasks.&lt;/p&gt; &lt;p&gt;You can explore more of what the &lt;a href="https://developers.redhat.com/products/ansible/overview"&gt;Ansible Automation Platform&lt;/a&gt; has to offer by &lt;a href="https://developers.redhat.com/products/ansible/download"&gt;downloading it&lt;/a&gt;. Additionally, there are &lt;a href="https://developers.redhat.com/e-books"&gt;e-books&lt;/a&gt; such as, &lt;a href="https://developers.redhat.com/e-books/automation-at-the-edge"&gt;Automation at the edge&lt;/a&gt;, &lt;a href="https://developers.redhat.com/e-books/choosing-automation-tool"&gt;Choosing an Automation Tool&lt;/a&gt;, and &lt;a href="https://developers.redhat.com/e-books/it-executives-guide-automation"&gt;An IT executive's guide to automation&lt;/a&gt;. A cheat sheet is also available for &lt;a href="https://developers.redhat.com/cheat-sheets/wifi-automation-ansible-and-sd-wan-meraki-cheat-sheet"&gt;WiFi automation with Ansible and SD&lt;/a&gt; that provides a quick reference for network automation tasks.&lt;/p&gt; &lt;p&gt;The &lt;a href="https://developers.redhat.com/articles/2023/06/15/how-use-ansible-create-vm-azure-workflow"&gt;final article&lt;/a&gt; in this 3-part series will demonstrate how to simplify the process of creating VMs in Azure by using workflow templates. Workflow templates can help standardize the process of creating VMs and reduce the amount of manual intervention required. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/06/15/how-use-ansible-create-vm-azure" title="How to use Ansible to create a VM on Azure"&gt;How to use Ansible to create a VM on Azure&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Deepankar Jain</dc:creator><dc:date>2023-06-15T18:00:00Z</dc:date></entry><entry><title>How to automate VM creation on Azure with Ansible CLI</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/06/15/how-automate-vm-creation-azure-ansible-cli" /><author><name>Deepankar Jain</name></author><id>54f40aea-f407-4a04-a9c5-da85ffe5427a</id><updated>2023-06-15T07:00:00Z</updated><published>2023-06-15T07:00:00Z</published><summary type="html">&lt;p&gt;In this article, we will demonstrate how to use the Red Hat Ansible Automation Platform command-line interface (CLI) to create a virtual machine on Microsoft Azure. We will walk you through the steps required to get started with Ansible Automation Platform and Azure, including setting up the necessary resources and creating a VM using the Azure module and Ansible Automation Platform.&lt;/p&gt; &lt;p&gt;This series covers the end-to-end process of creating a Virtual Machine(VM) on Azure using Ansible Automation Platform. This 3-part series includes:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;Part 1: How to automate VM creation on Azure with Ansible CLI&lt;/strong&gt;&lt;/li&gt; &lt;li&gt;Part 2: &lt;a href="https://developers.redhat.com/articles/2023/06/15/how-use-ansible-create-vm-azure"&gt;How to use Ansible to create a VM on Azure&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Part 3: &lt;a href="https://developers.redhat.com/articles/2023/06/15/how-use-ansible-create-vm-azure-workflow"&gt;How to use Ansible to create a VM on Azure via workflow&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;By the end of this article, you'll have a better understanding of how to use Ansible Automation Platform CLI to manage VMs and how this streamlines your infrastructure management workflows.&lt;/p&gt; &lt;h2&gt;Prerequisites&lt;/h2&gt; &lt;p&gt;Before you begin this tutorial, complete the following:&lt;/p&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;Make sure &lt;a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html"&gt;Ansible Automation Platform&lt;/a&gt; is installed on your system.&lt;/li&gt; &lt;li aria-level="1"&gt;Create a Microsoft Azure account.&lt;/li&gt; &lt;li aria-level="1"&gt;Install &lt;a href="https://galaxy.ansible.com/azure/azcollection"&gt;Ansible content collection for Azure&lt;/a&gt; on your system.&lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;How to use the Ansible CLI to create a VM&lt;/h2&gt; &lt;p&gt;Follow these steps to create a virtual machine using Ansible Automation Platform CLI:&lt;/p&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;&lt;a href="https://learn.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal"&gt;Create a service principal and give permissions in Azure&lt;/a&gt;.&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;a href="https://learn.microsoft.com/en-us/azure/industry/training-services/microsoft-community-training/frequently-asked-questions/generate-new-clientsecret-link-to-key-vault"&gt;Generate the client secret for service principal&lt;/a&gt;.&lt;/li&gt; &lt;li aria-level="1"&gt;You should now have a&lt;strong&gt; subscriptionid, tenantid, clientid and client secret &lt;/strong&gt;that you can use to access your Azure Account and launch a VM.&lt;/li&gt; &lt;li aria-level="1"&gt;Open any text editor on your local machine and copy the following yml into it:&lt;/li&gt; &lt;/ul&gt;&lt;pre&gt; &lt;code class="language-yaml"&gt;--- # Get facts for the user - name: Create a Virtual Machine on Azure Using Ansible hosts: localhost vars: vm_name: "Test-Ansible" vm_size: "Standard_B1ls" vm_image: "RedHat:RHEL:8-LVM:latest" vm_username: "testansible" vm_password: "my-password@1234" rg_name: "test-ansible" vnet_name: "test-ansible" subnet_name: "test-ansible" location: "centralindia" subscription_id: &lt;YOUR SUBSCRIPTION ID&gt; tenant: &lt;YOUR TENANT ID&gt; client_id: &lt;YOUR CLIENT ID&gt; secret: &lt;YOUR SECRET&gt; tasks: - name: Create a Resource Group azure.azcollection.azure_rm_resourcegroup: subscription_id: "{{ subscription_id }}" tenant: "{{ tenant }}" client_id: "{{ client_id }}" secret: "{{ secret }}" name: "{{ rg_name }}" location: "{{ location }}" register: rg - name: Create a Virtual Network azure.azcollection.azure_rm_virtualnetwork: subscription_id: "{{ subscription_id }}" tenant: "{{ tenant }}" client_id: "{{ client_id }}" secret: "{{ secret }}" resource_group: "{{ rg_name }}" name: "{{ vnet_name }}" address_prefixes: "10.0.0.0/16" register: vnet - name: Create a subnet azure.azcollection.azure_rm_subnet: subscription_id: "{{ subscription_id }}" tenant: "{{ tenant }}" client_id: "{{ client_id }}" secret: "{{ secret }}" resource_group: "{{ rg_name }}" virtual_network_name: "{{ vnet_name }}" name: "{{ subnet_name }}" address_prefix: "10.0.0.0/24" register: subnet - name: Create a public IP address azure.azcollection.azure_rm_publicipaddress: subscription_id: "{{ subscription_id }}" tenant: "{{ tenant }}" client_id: "{{ client_id }}" secret: "{{ secret }}" resource_group: "{{ rg_name }}" allocation_method: static name: "{{ vm_name }}-public-ip" register: public_ip - name: Create a network security group and configure the security group azure.azcollection.azure_rm_securitygroup: subscription_id: "{{ subscription_id }}" tenant: "{{ tenant }}" client_id: "{{ client_id }}" secret: "{{ secret }}" resource_group: "{{ rg_name }}" name: "{{ vm_name }}-nsg" rules: - name: "AllowSSH" protocol: Tcp direction: Inbound priority: 1000 access: Allow source_address_prefix: "*" source_port_range: "*" destination_port_range: "22" destination_address_prefix: "*" register: nsg - name: Create a Virtual Network Interface Card azure.azcollection.azure_rm_networkinterface: subscription_id: "{{ subscription_id }}" tenant: "{{ tenant }}" client_id: "{{ client_id }}" secret: "{{ secret }}" resource_group: "{{ rg_name }}" name: "{{ vm_name }}-nic" virtual_network: "{{ vnet_name }}" subnet_name: "{{ subnet_name }}" public_ip_name: "{{ vm_name }}-public-ip" security_group: "{{ vm_name }}-nsg" - name: Create a vm_image azure.azcollection.azure_rm_virtualmachine: subscription_id: "{{ subscription_id }}" tenant: "{{ tenant }}" client_id: "{{ client_id }}" secret: "{{ secret }}" resource_group: "{{ rg_name }}" name: "{{ vm_name }}" vm_size: "{{ vm_size }}" admin_username: "{{ vm_username }}" admin_password: "{{ vm_password }}" image: offer: "CentOS" publisher: "OpenLogic" sku: "7.5" version: "latest" os_disk_caching: ReadWrite os_disk_name: "{{ vm_name }}-os-disk" network_interface_names: - "{{ vm_name }}-nic" network_interfaces: - name: "{{ vm_name }}-nic" properties: primary: True availability_set: null ssh_public_keys: [] ssh_password_enabled: true &lt;/code&gt;&lt;/pre&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;Save and close the file.&lt;/li&gt; &lt;li aria-level="1"&gt;Open the terminal in the directory where the file is located on your local machine.&lt;/li&gt; &lt;li aria-level="1"&gt;Run the following command: &lt;pre&gt; &lt;code class="language-bash"&gt;ansible-playbook &lt;filename&gt;.yml&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This is the output:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-yaml"&gt;ansible-playbook -i inventory azure_cli.yml PLAY [Create a Virtual Machine on Azure Using Ansible] ************************************************************************************************************************************************************ TASK [Gathering Facts] ******************************************************************************************************************************************************************************************** ok: [localhost] TASK [Create a Resource Group] ************************************************************************************************************************************************************************************ changed: [localhost] TASK [Create a Virtual Network] *********************************************************************************************************************************************************************************** changed: [localhost] TASK [Create a subnet] ******************************************************************************************************************************************************************************************** changed: [localhost] TASK [Create a public IP address] ********************************************************************************************************************************************************************************* changed: [localhost] TASK [Create a network security group and configure the security group] ******************************************************************************************************************************************* changed: [localhost] TASK [Create a Virtual Network Interface Card] ******************************************************************************************************************************************************************** [DEPRECATION WARNING]: Setting ip_configuration flatten is deprecated and will be removed. Using ip_configurations list to define the ip configuration. This feature will be removed in version [2, 9]. Deprecation warnings can be disabled by setting deprecation_warnings=False in ansible.cfg. changed: [localhost] TASK [Create a vm_image] ****************************************************************************************************************************************************************************************** [WARNING]: Both option network_interface_names and its alias network_interfaces are set. changed: [localhost] PLAY RECAP ******************************************************************************************************************************************************************************************************** localhost : ok=8 changed=7 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 &lt;/code&gt;&lt;/pre&gt; Figure 1 shows the the Microsoft Azure VM. &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/screenshot_from_2023-04-26_13-04-45.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/screenshot_from_2023-04-26_13-04-45.png?itok=57gOPDNO" width="600" height="297" alt="A screenshot of the Microsoft Azure virtual machine." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 1: The Microsoft Azure virtual machine.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;What’s next?&lt;/h2&gt; &lt;p&gt;In this article, we demonstrated how to create a VM using &lt;a href="https://developers.redhat.com/learn/ansible"&gt;Ansible Automation Platform&lt;/a&gt;. If you followed this step-by-step guide, you should now have a good understanding of how to use Ansible Automation Platform to automate the creation of a VM.&lt;/p&gt; &lt;p&gt;In our &lt;a href="https://developers.redhat.com/articles/2023/06/15/how-use-ansible-create-vm-azure"&gt;next article&lt;/a&gt; in this series, we will explore how &lt;a href="https://developers.redhat.com/products/ansible/overview"&gt;Ansible Automation Platform&lt;/a&gt; further eases the process of creating VMs by defining infrastructure as code, tracking infrastructure changes, and enforcing compliance policies.&lt;/p&gt; &lt;p&gt;&lt;a href="https://developers.redhat.com/products/ansible/getting-started"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Get started&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; with Ansible Automation Platform by exploring interactive hands-on labs. &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://developers.redhat.com/products/ansible/download"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Download Ansible Automation Platform&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; at no cost and begin your automation journey. You can refer to &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://developers.redhat.com/e-books/choosing-automation-tool"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;An IT executive's guide to automation&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; e-book for a better understanding of the Ansible Automation Platform.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/06/15/how-automate-vm-creation-azure-ansible-cli" title="How to automate VM creation on Azure with Ansible CLI"&gt;How to automate VM creation on Azure with Ansible CLI&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Deepankar Jain</dc:creator><dc:date>2023-06-15T07:00:00Z</dc:date></entry><entry><title type="html">Java 21 Unnamed Classes and Instance Main Methods</title><link rel="alternate" href="https://www.mastertheboss.com/java/java-21-unnamed-classes-and-instance-main-methods/" /><author><name>F.Marchioni</name></author><id>https://www.mastertheboss.com/java/java-21-unnamed-classes-and-instance-main-methods/</id><updated>2023-06-13T10:38:54Z</updated><content type="html">Java 21 introduces two language core features: Unnamed Java Classes and a new launch protocol which allows running Java classes in a simpler format. In this article we will cover in detail these new features explaining how they can simplify your daily Java coding. Java 21 introduces two core features that will simplify the coding ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title>Improvements to Native Image JFR support in GraalVM for JDK 20</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/06/13/improvements-native-image-jfr-support-graalvm-jdk-20" /><author><name>Robert Toyonaga</name></author><id>cadfd7a6-afc0-41dd-af7f-cd88a02ab360</id><updated>2023-06-13T07:00:00Z</updated><published>2023-06-13T07:00:00Z</published><summary type="html">&lt;p&gt;This article describes the improvements to the Native Image JFR support in GraalVM JDK 20. This is a follow up to a previous article's section, &lt;a href="https://developers.redhat.com/articles/2021/07/23/jdk-flight-recorder-support-graalvm-native-image-journey-so-far#implementing_jdk_flight_recorder_support_for_graalvm_native_image"&gt;Implementing JDK Flight Recorder support for GraalVM Native Image&lt;/a&gt;. JDK Flight Recorder (JFR) is a powerful tool that assists the profiling, debugging, and monitoring of &lt;a href="https://developers.redhat.com/java"&gt;Java&lt;/a&gt; applications. We will discuss the new developments available in GraalVM for JDK 17 and JDK 20.&lt;/p&gt; &lt;h2&gt;3 steps to build a native image with JFR&lt;/h2&gt; &lt;p&gt;These steps illustrate the simplest way to use JFR with Native Image. You can also start a JFR recording over a JMX connection as described in the sections that follow, or by using the &lt;code&gt;jdk.jfr.Recording&lt;/code&gt; API from within your application code.&lt;/p&gt; &lt;ol&gt;&lt;li&gt;Compile your application to byte code as follows: &lt;pre&gt; &lt;code class="language-bash"&gt;$JAVA_HOME/bin/javac YourApplication.java&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;li&gt;Use the &lt;code&gt;--enable-monitoring &lt;/code&gt;option to build a native image with JFR support: &lt;pre&gt; &lt;code class="language-bash"&gt;native-image --enable-monitoring=jfr YourApplication&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;li&gt;Run with Flight Recorder. &lt;pre&gt; &lt;code&gt;./yourapplication -XX:StartFlightRecording=duration=60s,filename=recording.jfr&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;/ol&gt;&lt;h2&gt;New supported features&lt;/h2&gt; &lt;p&gt;This section will provide a brief rundown of the new major JFR features available in Native Image.&lt;/p&gt; &lt;h3&gt;Stack traces&lt;/h3&gt; &lt;p&gt;The first big improvement to JFR in Native Image is support for event stack traces. This also allows for method profiling which can provide insight into where your application is spending the most time, as shown in Figure 1. Events now carry stack traces so you can easily see where they are getting emitted. &lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/method_profiling_0.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/method_profiling_0.png?itok=PJQBDiyJ" width="600" height="420" alt="Method Profiling page in JMC shown with flame graph." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;Remote JMX connection&lt;/h3&gt; &lt;p&gt;Remote connection via JMX is also possible, the &lt;code&gt;jdk.management.jfr.FlightRecorderMXBean&lt;/code&gt;. This means that JFR recordings can be started remotely from out of process (from either another JVM or native image). Unfortunately, the Flight Recorder wizard in JMC does not recognize non-hotspot JVMs, which means you must interact with FlightRecorderMXBean from the &lt;strong&gt;MBean Browser&lt;/strong&gt; tab, as shown in Figure 2.&lt;/p&gt; &lt;p&gt;Remote JMX support in Native Image is still experimental, so you can expect more changes in this area in the future. Currently, PlatformMXBeans (i.e., ThreadMXBean) are only partially supported because the underlying implementations in SubstrateVM do not exist yet. The amount of reflection, dynamic proxy, and serialization metadata configuration required to support remote JMX is large because it is unknown ahead of time what MBeans and operations will be used. This means that JMX support results in an image size increase of a little over 20 MB. Please see the &lt;a href="https://www.graalvm.org/dev/reference-manual/native-image/guides/build-and-run-native-executable-with-remote-jmx/"&gt;GraalVM website&lt;/a&gt; for more information on remote JMX and its limitations.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/flightrecordermxbean.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/flightrecordermxbean.png?itok=CqTQiPkk" width="600" height="271" alt="The FlightRecorderMXBean operations in JMC." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 2. FlightRecorderMXBean operations in JMC.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;How to create a JFR Recording using JMC over JMX&lt;/h4&gt; &lt;p&gt;1. Build your native image with: &lt;code&gt;--enable-monitoring=all or --enable-monitoring=jvmstat,jfr,jmxclient,jmxserver&lt;/code&gt;&lt;/p&gt; &lt;pre&gt; &lt;code&gt;native-image --enable-monitoring=all -m jdk.httpserver&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;code&gt;jvmstat&lt;/code&gt; option makes your application discoverable. The &lt;code&gt;jfr&lt;/code&gt; option adds JDK Flight Recorder Support. The &lt;code&gt;jmxclient&lt;/code&gt;/&lt;code&gt;jmxserver&lt;/code&gt; options add support for outgoing/incoming JMX connections.&lt;/p&gt; &lt;p&gt;2. Start your native image executable with JMX options. Disclaimer: these options disable SSL and password authentication (both of which are supported, but aren’t included here for convenience of the demo).&lt;/p&gt; &lt;pre&gt; &lt;code&gt;./jdk.httpserver -Dcom.sun.management.jmxremote.authenticate=false \ -Djava.rmi.server.hostname=localhost \ -Dcom.sun.management.jmxremote.port=9996 \ -Dcom.sun.management.jmxremote.ssl=false \ -Dcom.sun.management.jmxremote.local.only=false &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;3. Open JMC and select your application in the JVM browser (there's no JVM but it'll show up there because you built with jvmstat).&lt;/p&gt; &lt;p&gt;4. Navigate to the &lt;strong&gt;MBean Browser&lt;/strong&gt; tab and select &lt;strong&gt;FlightRecorderMXBean&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;5. Select the &lt;strong&gt;Operations&lt;/strong&gt; tab and execute the &lt;strong&gt;newRecording&lt;/strong&gt; operation. Make note of the returned recording ID.&lt;/p&gt; &lt;p&gt;6. Execute &lt;strong&gt;setPredefinedConfiguration&lt;/strong&gt; operation, providing the recording ID from the previous step as well as &lt;strong&gt;profile&lt;/strong&gt; as the second argument.&lt;/p&gt; &lt;p&gt;7. Execute the &lt;strong&gt;startRecording&lt;/strong&gt; operation, providing the recording ID from the previous step.&lt;/p&gt; &lt;p&gt;8. When you're ready to dump the recording, execute the &lt;strong&gt;copyTo&lt;/strong&gt; operation, providing the recording ID as well as a filename (&lt;code&gt;MyRecording.jfr&lt;/code&gt;).&lt;/p&gt; &lt;h3&gt;Event streaming&lt;/h3&gt; &lt;p&gt;Now event streaming has experimental support in Native Image. JFR event streaming was introduced in OpenJDK 14 and allows for streaming of events from an ongoing recording. Previously, recording had to be dumped to a JFR snapshot before the event data could be read. However, now an application can subscribe to a stream of its own event data (or even that of another process) and register callbacks triggered by specific events. A current limitation of event streaming in Native Image is that stack traces are not available for streamed events. This is actively being worked on and does not affect stack traces available in a snapshot file.&lt;/p&gt; &lt;h2&gt;New supported events&lt;/h2&gt; &lt;p&gt;This section highlights the new support for events grouped by category.&lt;/p&gt; &lt;h3&gt;Monitor and thread events&lt;/h3&gt; &lt;p&gt;There is now support for monitor and thread-related events. These events can provide insight into where and why threads are often stopped or waiting.&lt;/p&gt; &lt;ul&gt;&lt;li&gt;jdk.ThreadSleep&lt;/li&gt; &lt;li&gt;jdk.ThreadPark&lt;/li&gt; &lt;li&gt;jdk.JavaMonitorEnter&lt;/li&gt; &lt;li&gt;jdk.JavaMonitorWait&lt;/li&gt; &lt;li&gt;jdkJavaMonitorInflate&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;Figure 3 shows how these new events can be used in combination with newly supported stack traces to generate flame graphs identifying where threads are blocked.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/blockedMonitor.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/blockedMonitor.png?itok=TLVsIXRA" width="600" height="325" alt="In Native Image JFR, a flame graph showing blocking on monitors." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;Allocation events&lt;/h3&gt; &lt;p&gt;The following allocation event is now supported. This event is useful for discerning the places where your application does most of its allocations. Since this event generates a lot of data/overhead, it is disabled by default (similar to OpenJDK). You can use it by providing a custom settings file with the event set to &lt;strong&gt;enabled&lt;/strong&gt; (&lt;code&gt;-XX:StartFlightRecording=settings=/path/to/settings.jfc&lt;/code&gt;).&lt;/p&gt; &lt;ul&gt;&lt;li&gt;jdk.ObjectAllocationInNewTLAB&lt;/li&gt; &lt;/ul&gt;&lt;h3&gt;Container events&lt;/h3&gt; &lt;p&gt;The following events related to containers are now supported:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;jdk.ContainerCPUThrottling&lt;/li&gt; &lt;li&gt;jdk.ContainerCPUUsage&lt;/li&gt; &lt;li&gt;jdk.ContainerConfiguration&lt;/li&gt; &lt;li&gt;jdk.ContainerIOUsage&lt;/li&gt; &lt;li&gt;jdk.ContainerMemoryUsage&lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;What's next?&lt;/h2&gt; &lt;p&gt;Support for leak detection via the &lt;code&gt;jdk.OldObjectSample&lt;/code&gt; event is in progress. This is a sampling based approach that tracks large long-lived objects to provide insights into potential memory leaks. Support for allocation profiling is also in development via the &lt;code&gt;jdk.ObjectAllocation&lt;/code&gt; event and emission throttling. Throttling is important to control the overhead associated with instrumenting object allocations. Support for other built-in events available in OpenJDK/Hotspot continues.&lt;/p&gt; &lt;p&gt;Other features such as in memory chunk rotation are not yet being worked on. Other features are unsupported because they are not applicable to Native Image. Specifically, events related to compilation, dynamic bytecode instrumentation, and class loading are not applicable. Control of JFR via jcmd is also not possible because jcmd is unsupported in Native Image.&lt;/p&gt; &lt;p&gt;Please visit &lt;a href="https://github.com/oracle/graal/issues/5410"&gt;this GitHub issue&lt;/a&gt; for the most up-to-date list of supported JFR events in Native Image. In addition to these built-in events, the JFR custom events API is also supported. Users can create and emit their own custom application level events by extending &lt;code&gt;jdk.jfr.Event&lt;/code&gt; class.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/06/13/improvements-native-image-jfr-support-graalvm-jdk-20" title="Improvements to Native Image JFR support in GraalVM for JDK 20"&gt;Improvements to Native Image JFR support in GraalVM for JDK 20&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Robert Toyonaga</dc:creator><dc:date>2023-06-13T07:00:00Z</dc:date></entry><entry><title type="html">Quarkus Newsletter #33 - June</title><link rel="alternate" href="https://quarkus.io/blog/quarkus-newsletter-33/" /><author><name>James Cobb</name></author><id>https://quarkus.io/blog/quarkus-newsletter-33/</id><updated>2023-06-13T00:00:00Z</updated><content type="html">Check out the June Newsletter. Read "A Guide to the Quarkus 3 Azure Functions Extension: Bootstrap Java Microservices with Ease" by Daniel Oh &amp;amp; Erik Costlow and to learn how Quarkus integrates Java microservices into Azure Functions with an improved developer experience. Check out "Quarkus: Java revisited!" by Willem Meints...</content><dc:creator>James Cobb</dc:creator></entry><entry><title type="html">Getting Started with Testcontainers for Java</title><link rel="alternate" href="https://www.mastertheboss.com/various-stuff/testing-java/getting-started-with-testcontainers-for-java/" /><author><name>F.Marchioni</name></author><id>https://www.mastertheboss.com/various-stuff/testing-java/getting-started-with-testcontainers-for-java/</id><updated>2023-06-12T15:04:48Z</updated><content type="html">Introduction In modern software development, it is crucial to write robust and reliable tests to ensure the quality of your applications. One essential aspect of testing is dealing with dependencies, such as databases or external services. Testcontainers is an excellent Java library that provides lightweight, disposable containers for running dependencies during tests. In this tutorial, ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title type="html">gRPC and WildFly - Part II: Exposing Jakarta RESTFul Web Services to gRPC</title><link rel="alternate" href="https://resteasy.dev/2023/06/11/grpc-in-wildfly-pt2/" /><author><name /></author><id>https://resteasy.dev/2023/06/11/grpc-in-wildfly-pt2/</id><updated>2023-06-11T00:00:00Z</updated><dc:creator /></entry><entry><title type="html">Kogito 1.39.0 released!</title><link rel="alternate" href="https://blog.kie.org/2023/06/kogito-1-39-0-released.html" /><author><name>Cristiano Nicolai</name></author><id>https://blog.kie.org/2023/06/kogito-1-39-0-released.html</id><updated>2023-06-09T12:23:04Z</updated><content type="html">We are glad to announce that the Kogito 1.39.0 release is now available! This goes hand in hand with , release. From a feature point of view, we have included a series of new features and bug fixes, including: * User can now send a custom CloudEvent ID in Serverless Workflow Knative custom functions * Users can now override default behavior of Java service custom type  (which creates object instance using reflection and default constructor)  when using embedded serverless workflow execution (so they can, for example, use a spring boot bean)  * Fixed bug that prevent task deadlines functionality to work * Fixed issue on data translation when using RestWorkItemHandler within a for each state * [SW Operator] Update Serverless Operator to use CNCF go-sdk model * Fixed bug that prevents sending Process, UserTask, and Variable events in knative eventing. For more details head to the complete . All artifacts are available now: * Kogito runtime artifacts are available on Maven Central. * Kogito examples can be found . * Kogito images are available on . * Kogito operator is available in the in OpenShift and Kubernetes. * Kogito tooling 0.29.0 artifacts are available at the . A detailed changelog for 1.39.0 can be found in . New to Kogito? Check out our website . Click the "Get Started" button. The post appeared first on .</content><dc:creator>Cristiano Nicolai</dc:creator></entry><entry><title>Deploy and test Kubernetes containers using Podman Desktop</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/06/09/deploy-and-test-kubernetes-containers-using-podman-desktop" /><author><name>Cedric Clyburn</name></author><id>167e48b2-9b2d-4670-b698-b7d752c59e6d</id><updated>2023-06-09T07:00:00Z</updated><published>2023-06-09T07:00:00Z</published><summary type="html">&lt;p&gt;&lt;a href="https://podman-desktop.io/"&gt;Podman Desktop&lt;/a&gt; (&lt;a href="https://developers.redhat.com/articles/2023/05/23/podman-desktop-now-generally-available"&gt;now generally available&lt;/a&gt;) is an amazing tool for building, running, and managing &lt;a href="https://developers.redhat.com/topics/containers"&gt;containerized applications&lt;/a&gt; locally—but in a real-world environment, you need to deploy your applications on container orchestration platforms such as &lt;a href="https://kubernetes.io/"&gt;Kubernetes&lt;/a&gt;. If you’re looking for an enterprise-grade Kubernetes, look no further than &lt;a href="https://www.redhat.com/en/technologies/cloud-computing/openshift"&gt;Red Hat OpenShift&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;Let’s deploy and test a containerized application from your desktop to the free &lt;a href="https://developers.redhat.com/developer-sandbox"&gt;Developer Sandbox for Red Hat OpenShift&lt;/a&gt; using Podman Desktop’s Developer Sandbox for Red Hat OpenShift extension.&lt;/p&gt; &lt;h2&gt;Getting started&lt;/h2&gt; &lt;p&gt;If you haven’t already installed Podman Desktop (Figure 1), head to &lt;a href="https://podman-desktop.io/"&gt;podman-desktop.io&lt;/a&gt; to download the latest release to your machine, compatible with Windows, macOS, or &lt;a href="https://developers.redhat.com/topics/linux/"&gt;Linux&lt;/a&gt;.&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/podman-desktop.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/podman-desktop.png?itok=PWK8-lZ8" width="600" height="367" alt="Podman Desktop dashboard interface" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 1: The Podman Desktop dashboard.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;This tutorial uses the &lt;a href="https://developers.redhat.com/developer-sandbox"&gt;Developer Sandbox for Red Hat OpenShift&lt;/a&gt; extension, which allows you to deploy your containerized applications to a free, cloud-based OpenShift cluster for 30 days.  Using this extension, you can easily sign up for the Developer Sandbox and easily deploy pods or YAML to the hosted OpenShift environment without a local installation or leaving Podman Desktop.&lt;/p&gt; &lt;h3&gt;Install the Developer Sandbox extension&lt;/h3&gt; &lt;p&gt;To install the Developer Sandbox extension for Podman Desktop, navigate to the &lt;strong&gt;Settings&lt;/strong&gt; button on the lower-left corner of Podman Desktop. Next, select&lt;strong&gt; Extensions&lt;/strong&gt; from the left-hand menu. From there, install the &lt;strong&gt;Developer Sandbox&lt;/strong&gt; extension from the list of featured extensions (Figure 2). Podman Desktop also provides functionality to install new extensions from OCI images or even &lt;a href="https://podman-desktop.io/extend"&gt;Docker Desktop extensions&lt;/a&gt;!&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/podman-desktop-extensions.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/podman-desktop-extensions.png?itok=6w03Mi2K" width="600" height="367" alt="Podman Desktop extensions page" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 2: Installing the Developer Sandbox extension from the Extensions tab.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;After you click the button to install the &lt;strong&gt;Developer Sandbox&lt;/strong&gt; extension, you'll notice a new section under the &lt;strong&gt;Extensions&lt;/strong&gt; section on the left-hand side of the panel. Click the &lt;strong&gt;Red Hat Developer Sandbox &lt;/strong&gt;extension (Figure 3), and this is where you can see information related to the extension's status (as well as start, stop, or remove the extension).&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/podman-desktop-extension-status.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/podman-desktop-extension-status.png?itok=K1C4cQ4m" width="600" height="367" alt="Podman Desktop extension status" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 3: Viewing details about the Developer Sandbox extension once installed.&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;Register and connect to the Developer Sandbox&lt;/h3&gt; &lt;p&gt;For this tutorial, you can use the &lt;a href="https://developers.redhat.com/developer-sandbox"&gt;Developer Sandbox for Red Hat OpenShift&lt;/a&gt; to get a free OpenShift cluster for 30 days to deploy and test your applications. To get started, visit the &lt;strong&gt;Resources&lt;/strong&gt; section on the left-hand side of the &lt;strong&gt;Settings&lt;/strong&gt;. This is where you can connect to your Developer Sandbox environment using your OpenShift authentication token. For now, let's click the link to &lt;strong&gt;Sign up&lt;/strong&gt; for the Developer Sandbox, as shown in Figure 4). (If you already have a Developer Sandbox instance, you can skip to the next section.)&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/podman-desktop-sandbox-signup.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/podman-desktop-sandbox-signup.png?itok=JfOFDjye" width="600" height="367" alt="Podman Desktop Developer Sandbox signup" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 4: Click the link on the Resources tab to navigate to the Developer Sandbox sign-up page.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;The &lt;/span&gt;&lt;a href="https://developers.redhat.com/developer-sandbox"&gt;Developer Sandbox for Red Hat OpenShift&lt;/a&gt;&lt;span&gt; gives you access to a shared OpenShift and Kubernetes cluster at no cost, with &lt;/span&gt;14 GB RAM and 40 GB storage&lt;span&gt;. Simply log in using your Red Hat account and complete the phone verification process (Figure 5).&lt;/span&gt;&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/developer-sandbox-signup.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/developer-sandbox-signup.png?itok=5oOvM-lq" width="600" height="367" alt="Developer Sandbox signup page" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 5: Log in to the Developer Sandbox for Red Hat OpenShift.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Once you've logged into the Developer Sandbox, you can connect Podman Desktop to the OpenShift cluster. On the top right-hand side of your OpenShift cluster, select the drop-down menu under your Red Hat username and click &lt;strong&gt;Copy login command. &lt;/strong&gt;Click the &lt;strong&gt;Display token&lt;/strong&gt; button to reveal your cluster URL and token and copy the entire command, as illustrated in Figure 6.&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/developer-sandbox-authentication-token.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/developer-sandbox-authentication-token.png?itok=BJIsp-ZC" width="600" height="367" alt="Developer Sandbox authentication token" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 6: Retrieving the OpenShift authentication token from the OpenShift web console.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Return to Podman Desktop and select &lt;strong&gt;Create new Developer Sandbox&lt;/strong&gt; on the &lt;strong&gt;Resources&lt;/strong&gt; settings page. Here, you select a context name for your Developer Sandbox instance to easily find it within Podman Desktop, as well as paste in the full login command from the OpenShift web console. When you're ready, just click the &lt;strong&gt;Create&lt;/strong&gt; button to authenticate to your Red Hat OpenShift cluster (Figure 7).&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/podman-desktop-new-sandbox.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/podman-desktop-new-sandbox.png?itok=FMEZND8p" width="600" height="367" alt="Podman Desktop New Developer Sandbox form" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 7: Authenticate to your OpenShift cluster.&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;Deploy your application to the OpenShift cluster&lt;/h2&gt; &lt;p&gt;Now that you’ve connected to your OpenShift cluster through the Developer Sandbox extension for Podman Desktop, it’s time to deploy a containerized application. While this guide won’t cover building a container image from a &lt;a href="https://www.mankier.com/5/Containerfile"&gt;Containerfile&lt;/a&gt;, you can use Podman Desktop to pull an image down from a container registry before deploying it on the Developer Sandbox.&lt;/p&gt; &lt;h3&gt;Pull an image from a container registry&lt;/h3&gt; &lt;p&gt;Let’s go ahead and pull an example image from &lt;a href="https://quay.io/"&gt;Quay.io&lt;/a&gt;, an open-source public container registry similar to the &lt;a href="https://hub.docker.com/"&gt;Docker Hub&lt;/a&gt;. Within Podman Desktop, select the &lt;strong&gt;Images&lt;/strong&gt; tab from the left-hand side of the panel. Here, select &lt;strong&gt;Pull an image&lt;/strong&gt; in the upper right-hand corner of Podman Desktop.&lt;/p&gt; &lt;p&gt;For the image to pull, you can use a basic &lt;a href="https://developers.redhat.com/products/quarkus/getting-started"&gt;Quarkus&lt;/a&gt; demo application with the tag &lt;code&gt;quay.io/rhdevelopers/quarkus-demo:v1&lt;/code&gt;. Select &lt;strong&gt;Pull image&lt;/strong&gt; to begin the downloading process (Figure 8).&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/podman-desktop-quarkus-image.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/podman-desktop-quarkus-image.png?itok=6CvYMX0g" width="600" height="367" alt="Podman Desktop Quarkus Image" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 8: Using Podman Desktop to pull an image.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;With the image pulled to Podman Desktop, you can now run the image as a container, delete the image, or view the image’s history. Let's begin checking out this container locally before we go and deploy it to our Developer Sandbox. Testing locally allows you to ensure your applications will run smoothly in a Kubernetes or OpenShift environment before deploying them.&lt;/p&gt; &lt;p&gt;Back in the &lt;strong&gt;Images&lt;/strong&gt; section of the left-hand menu, select the newly downloaded Image, and click the &lt;strong&gt;Run Image&lt;/strong&gt; icon, as shown in Figure 9. Here, we'll select the default configuration and select &lt;strong&gt;Start&lt;/strong&gt; . Next, select the new container from the &lt;strong&gt;Containers&lt;/strong&gt; section, and you can view various information about the running container, including logs, access to the container's shell using a terminal, and even the Kubernetes YAML needed to create a running pod on your cluster of your container.&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/podman-desktop-run-container.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/podman-desktop-run-container.png?itok=xI6fAPvX" width="600" height="367" alt="Podman Desktop running a container" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 9: Test and view details about the running container.&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;Deploying your container to the Developer Sandbox&lt;/h3&gt; &lt;p&gt;With your container either running or stopped, we can now deploy it to our Developer Sandbox using the registered cluster information in your local &lt;code&gt;kubeconfig&lt;/code&gt; file. Before doing so, let's ensure that we've selected the correct Kubernetes namespace first by clicking the &lt;strong&gt;Podman Desktop Tray&lt;/strong&gt;, selecting &lt;strong&gt;Kubernetes&lt;/strong&gt;, and choosing the &lt;strong&gt;Developer Sandbox &lt;/strong&gt;context (or another custom name). See Figure 10. Back in Podman Desktop, select the &lt;strong&gt;Deploy&lt;/strong&gt; button (rocket emoji) to generate a Kubernetes pod on your cluster.&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/podman-desktop-deploy-kubernetes_0.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/podman-desktop-deploy-kubernetes_0.png?itok=WQkSCM9X" width="600" height="367" alt="Podman Desktop deploying to Kubernetes" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 10: Switching the Kubernetes context and deploying the Pod.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;br /&gt; You can use the default generated Pod Name, review the Kubernetes YAML, select &lt;strong&gt;Create&lt;/strong&gt;&lt;strong&gt; OpenShift routes&lt;/strong&gt;, and click &lt;strong&gt;Deploy&lt;/strong&gt; again to start the process of pod creation on your Developer Sandbox (Figure 11). The Developer Sandbox extension will handle the creation of the deployment, service, and route in deploying this container to our cluster.&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/podman-desktop-deploy-button.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/podman-desktop-deploy-button.png?itok=EOLp9sQm" width="600" height="367" alt="Podman Desktop Deploy Button" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 11: Click Deploy to create the pod in your Developer Sandbox.&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;Verify deployment status using the OpenShift web console&lt;/h3&gt; &lt;p&gt;Now that your container has been deployed to the cluster using the Developer Sandbox extension for Podman Desktop, let’s take a look at the OpenShift web console to make sure everything looks right.&lt;/p&gt; &lt;p&gt;Back in the Developer Sandbox, head to the &lt;strong&gt;Developer&lt;/strong&gt; view and select the &lt;strong&gt;Topology&lt;/strong&gt; tab from the left-hand side menu. Here, you can see details about the new Quarkus application deployment, the service that has just been created, the running pod, and a link to the route created in order to access your application (Figure 12). Select the link to view the application in your browser.&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/developer-sandbox-verify-deplopyment.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/developer-sandbox-verify-deplopyment.png?itok=utHIIzKf" width="600" height="367" alt="Developer Sandbox verification of pod deployment" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 11: View the application in your browser.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Additionally, you can also select the Pod name to view relevant details like metrics, logs, and use the terminal, just how we did using Podman Desktop (Figure 12).&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/developer-sandbox-pod-logs.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/developer-sandbox-pod-logs.png?itok=Fq8Im97B" width="600" height="367" alt="Developer Sandbox viewing of logs" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 12: View Pod details in the OpenShift web console.&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;Conclusion&lt;/h2&gt; &lt;p&gt;Congratulations! You’ve just learned how to deploy a container image to the no-cost &lt;a href="https://developers.redhat.com/developer-sandbox"&gt;Developer Sandbox for Red Hat OpenShift&lt;/a&gt; directly from &lt;a href="https://podman-desktop.io/"&gt;Podman Desktop&lt;/a&gt; using the Developer Sandbox extension. For more information, check out the Podman Desktop &lt;a href="https://podman-desktop.io/docs/intro"&gt;documentation&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Explore other Podman and container resources on Red Hat Developer:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;&lt;a href="http://developers.redhat.com/articles/2023/03/01/podman-desktop-introduction"&gt;What is Podman Desktop? A developer's introduction&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2023/02/14/remote-container-development-vs-code-and-podman"&gt;Remote container development with VS Code and Podman&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/10/24/podman-expands-desktop#motivation_for_the_podman_desktop_initiative"&gt;Podman expands to the Desktop&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/06/09/deploy-and-test-kubernetes-containers-using-podman-desktop" title="Deploy and test Kubernetes containers using Podman Desktop"&gt;Deploy and test Kubernetes containers using Podman Desktop&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Cedric Clyburn</dc:creator><dc:date>2023-06-09T07:00:00Z</dc:date></entry><entry><title type="html">Eclipse Vert.x JDBC Client 4.4.3.1 released!</title><link rel="alternate" href="https://vertx.io/blog/eclipse-vert-x-jdbc-client-4-3-3-1" /><author><name>Julien Viet</name></author><id>https://vertx.io/blog/eclipse-vert-x-jdbc-client-4-3-3-1</id><updated>2023-06-08T00:00:00Z</updated><content type="html">Eclipse Vert.x JDBC Client version 4.4.3.1 has just been released.</content><dc:creator>Julien Viet</dc:creator></entry></feed>
